/*
 * НТТ test task server API
 *
 * REST API для сервера в тестовом задании, основанное на OpenAPI 3.0-спецификации.  [Лариса Морожникова](https://t.me/l_milk)
 *
 * API version: 1.0.0
 * Contact: larisa.moroz@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
)

func FoldersGetPost(db *sql.DB, pgTableName string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {


		var body FoldersGetBody

		err := json.NewDecoder(r.Body).Decode(&body)
		if checkErrorBadRequest(err, w) {
			return
		}


		path := strings.TrimRight(strings.TrimSpace(body.Path), "/")

		var row *sql.Row
		var folderId int

		selectParentQuery := fmt.Sprintf("SELECT id FROM %s WHERE parent_id IS NULL LIMIT 1", pgTableName)
		row = db.QueryRow(selectParentQuery)

		err = row.Scan(&folderId)
		if checkSQLError(err, w, "Cannot select parent folder ID") {
			return
		}

		if path != "" {
			parts := strings.Split(path, "/")
			if len(parts) > 2 {
				selectItemQuery := fmt.Sprintf(`
WITH RECURSIVE file_structure AS (
  SELECT d.*, '/' || d.name as path FROM %s d WHERE d.parent_id = $1 AND d.name = $2
  UNION ALL
  SELECT f.*, fs.path || '/' || f.name as path FROM %s f JOIN file_structure fs ON f.parent_id = fs.id
)
SELECT id FROM file_structure WHERE path = $3 LIMIT 1;`, pgTableName, pgTableName)
				row = db.QueryRow(selectItemQuery, folderId, parts[1], path)

			} else {
				selectItemQuery := fmt.Sprintf("SELECT id FROM %s WHERE parent_id = $1 AND name = $2 LIMIT 1", pgTableName)
				row = db.QueryRow(selectItemQuery, folderId, parts[1])
			}
			err = row.Scan(&folderId)
			if checkSQLError(err, w, "Cannot select folder ID") {
				return
			}
		}

		selectChildrenQuery := fmt.Sprintf("SELECT d.*, EXISTS (SELECT 1 FROM %s AS sub WHERE sub.parent_id = d.id) AS has_nested FROM %s as d WHERE parent_id = $1", pgTableName, pgTableName)
		rows, err := db.Query(selectChildrenQuery, folderId)
		if checkErrorInternal(err, w) {
			return
		}


		defer rows.Close()

		var children []FolderInfo
		for rows.Next() {
			var child FolderInfo
			err := rows.Scan(&child.Id, &child.ParentId, &child.Name, &child.Description, &child.HasNested)
			if checkErrorInternal(err, w) {
				return
			}
			child.Path = fmt.Sprintf("%s/%s", path, child.Name)
			child.IsOpen = false;
			children = append(children, child)
		}
		err = rows.Err()
		if checkErrorInternal(err, w) {
			return
		}
		log.Printf("FoldersGetPost selected children len = %d", len(children))

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(children)
	}
}
